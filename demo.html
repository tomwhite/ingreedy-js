<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ingreedy demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        .imgbox {
            display: grid;
            height: 100%;
        }
        .center-fit {
            max-width: 100%;
            max-height: 100vh;
            margin: auto;
        }
    </style>
</head>
<body>
<input type="file" accept="image/*" id="file-input">
<div class="imgbox">
    <img class="center-fit" id="output">
</div>
<textarea id="ingredients_box" rows="20" cols="40"></textarea>
<script>

  const fileInput = document.getElementById('file-input');
  fileInput.addEventListener('change', (e) => compress(e));

  function compress(e) {
    var MAX_WIDTH = 1024;
    var MAX_HEIGHT = 768;
    const fileName = e.target.files[0].name;
    const reader = new FileReader();
    reader.readAsDataURL(e.target.files[0]);
    reader.onload = event => {
        const img = new Image();
        img.src = event.target.result;

        img.onload = () => {
                var width = img.width;
                var height = img.height;

                if (width > height) {
                   if (width > MAX_WIDTH) {
                      height *= MAX_WIDTH / width;
                      width = MAX_WIDTH;
                   }
                } else {
                   if (height > MAX_HEIGHT) {
                      width *= MAX_HEIGHT / height;
                      height = MAX_HEIGHT;
                   }
                }

                const elem = document.createElement('canvas');
                elem.width = width;
                elem.height = height;
                const ctx = elem.getContext('2d');
                // img.width and img.height will contain the original dimensions
                ctx.drawImage(img, 0, 0, width, height);
                ctx.canvas.toBlob((blob) => {
                    const file = new File([blob], fileName, {
                        type: 'image/png',
                        lastModified: Date.now()
                    });
                }, 'image/png', 1);
                const dataUrl = elem.toDataURL('image/png');
                document.getElementById('output').src = dataUrl;
                const base64Img = dataUrl.replace('data:image/png;base64,', '');
                console.log(base64Img);
                makeVisionRequest(base64Img);
            },
            reader.onerror = error => console.log(error);
    };

    function makeVisionRequest(base64Img) {
        const data = {
            "requests":[
                {
                    "image": {
                        "content": base64Img
                    },
                    "features": [
                      {
                        "type": "DOCUMENT_TEXT_DETECTION"
                      }
                    ]
                }
            ]
        }
        console.log(data);

        var http = new XMLHttpRequest();
        var url = 'https://vision.googleapis.com/v1/images:annotate?key=AIzaSyC4zxRw4GIxO1RuUAezGwtnBl-KLkfRJ2E';

        http.open('POST', url, true);
        http.setRequestHeader('Content-Type', 'application/json; charset=utf-8');

        http.onreadystatechange = function() {
            if (http.readyState == 4 && http.status == 200) {
                const responseText = http.responseText;
                console.log(responseText);
                const response = JSON.parse(responseText);
                const centerBlock = getCenterBlock(response);
                console.log(centerBlock);
                const text = getTextFromBlock(centerBlock);
                console.log(text);
                const textArea = document.getElementById('ingredients_box');
                textArea.value = text;
            }
        }

        http.send(JSON.stringify(data));

        //var response = fakeResponse();
        //console.log(response);
        //var text = response["responses"][0]["textAnnotations"][0]["description"];
        //console.log(text);
        //const textArea = document.getElementById('ingredients_box');
        //textArea.value = text;
    }

    function fakeResponse() {
        return {
  "responses": [
    {
      "textAnnotations": [
        {
          "locale": "en",
          "description": "the mince will make the hamburgers\nsweet and juicy. The egg is not essential,\nalthough it helps to bind the burgers and\nincreases the food value.\n10g (1/202) butter\n50g (202) onion, very finely chopped\n450g (11b) beef (flank, chump or shin would be\nperfect), freshly minced\n1/2 teaspoon fresh thyme leaves\n1/2 teaspoon finely chopped parsley\n1 small organic egg, beaten\nsalt and freshly ground pepper\npork caul fat (optional)\noil or dripping\nMelt the butter in a saucepan and toss\nin the onion, sweating until soft but not\ncoloured. Leave to get cold. Meanwhile mix\nthe mince with the herbs and beaten egg,\nid the\n",
          "boundingPoly": {
            "vertices": [
              {
                "x": 21,
                "y": -7
              },
              {
                "x": 543,
                "y": -7
              },
              {
                "x": 543,
                "y": 769
              },
              {
                "x": 21,
                "y": 769
              }
            ]
          }
        }
        ]
        }
        ]
        }
    }

  }

  function getBlocks(response) {
    // get all the blocks on a page
    return response['responses'][0]['fullTextAnnotation']['pages'][0]['blocks'];
  }

  function getCenterBlock(response) {
    // get block that overlaps the center of the page
    // TODO: make this more robust by finding the nearest block that overlaps
    const page = response['responses'][0]['fullTextAnnotation']['pages'][0];
    const midx = page['width'] / 2;
    const midy = page['height'] / 2;
    const overlappingBlocks = getBlocks(response).filter(function(block) {
        const [minx, miny, maxx, maxy] = getExtents(block['boundingBox']['vertices']);
        return minx <= midx && midx <= maxx && miny <= midy && midy <= maxy;
    });
    return overlappingBlocks[0];
  }

  function getExtents(vertices) {
    // find the min and max extents of a set of vertices
    let minx = Number.MAX_SAFE_INTEGER;
    let miny = Number.MAX_SAFE_INTEGER;
    let maxx = Number.MIN_SAFE_INTEGER;
    let maxy = Number.MIN_SAFE_INTEGER;
    vertices.forEach(function(vertex) {
        if (vertex['x'] < minx) {
            minx = vertex['x'];
        }
        if (vertex['y'] < miny) {
            miny = vertex['y'];
        }
        if (vertex['x'] > maxx) {
            maxx = vertex['x'];
        }
        if (vertex['y'] > maxy) {
            maxy = vertex['y'];
        }
    });
    return [minx, miny, maxx, maxy];
  }

  function getTextFromBlock(block) {
    // construct the text that is in a block
    let text = '';
    block['paragraphs'].forEach(function(paragraph) {
        paragraph['words'].forEach(function(word) {
            word['symbols'].forEach(function(symbol) {
                text += symbol['text'];
                if ('detectedBreak' in symbol['property']) {
                    const detectedBreakType = symbol['property']['detectedBreak']['type'];
                    if (detectedBreakType === 'SPACE' || detectedBreakType === 'SURE_SPACE') {
                        text += ' ';
                    } else if (detectedBreakType === 'EOL_SURE_SPACE' || detectedBreakType === 'LINE_BREAK') {
                        text += '\n';
                    }
                }
            });
        });
    });
    return text;
  }

    var http = new XMLHttpRequest();
    var url = 'IMG_0220.JPG.google.json';

    http.open('GET', url, true);

    http.onreadystatechange = function() {
        if (http.readyState == 4 && http.status == 200) {
            const responseText = http.responseText;
            console.log(responseText);
            const response = JSON.parse(responseText);
            const blocks = getBlocks(response);
            console.log(blocks);
            blocks.forEach(function(block) {
                const text = getTextFromBlock(block);
                console.log(text);
            });
            const centerBlock = getCenterBlock(response);
            console.log(centerBlock);
            console.log(getTextFromBlock(centerBlock));

        }
    }

    //http.send();



</script>
</body>
</html>